package main

import (
	"bytes"
	"fmt"
	"math/big"
	"os"

	"github.com/consensys/gnark-crypto/ecc"
	"github.com/consensys/gnark-crypto/ecc/bn254/fr"
	"github.com/consensys/gnark/backend/groth16"
	groth16_bn254 "github.com/consensys/gnark/backend/groth16/bn254"
	"github.com/consensys/gnark/backend/witness"
	"github.com/consensys/gnark/frontend"
	"github.com/consensys/gnark/frontend/cs/r1cs"
)

// CubicCircuit defines a simple circuit
// x**3 + x + 5 == y
type CubicCircuit struct {
	// struct tags on a variable is optional
	// default uses variable name and secret visibility.
	X frontend.Variable `gnark:"x"`
	Y frontend.Variable `gnark:",public"`
}

// Define the circuit constraints
// x**3 + x + 5 == y
func (circuit *CubicCircuit) Define(api frontend.API) error {
	x3 := api.Mul(circuit.X, circuit.X, circuit.X)
	api.AssertIsEqual(circuit.Y, api.Add(x3, circuit.X, 5))
	return nil
}

// encode the proof and public witness into a format that can be used in solidity contract
func printEthProofs(vk groth16.VerifyingKey, proof groth16.Proof, validPublicWitness witness.Witness) {
	var buf bytes.Buffer
	_proof := proof.(*groth16_bn254.Proof)
	_, err := _proof.WriteRawTo(&buf)
	if err != nil {
		panic(err)
	}
	fpSize := 4 * 8
	proofBytes := buf.Bytes()
	// keep only fpSize * 8 bytes; for now solidity contract doesn't handle the commitment part.
	proofBytes = proofBytes[:32*8]
	if len(proofBytes) != fpSize*8 {
		panic("proofBytes != fpSize*8")
	}

	// public witness to hex
	bPublicWitness, err := validPublicWitness.MarshalBinary()
	if err != nil {
		panic(err)
	}
	// that's quite dirty...
	// first 4 bytes -> nbPublic
	// next 4 bytes -> nbSecret
	// next 4 bytes -> nb elements in the vector (== nbPublic + nbSecret)
	inputBytes := bPublicWitness[12:]
	if len(inputBytes)%fr.Bytes != 0 {
		panic("inputBytes mod fr.Bytes !=0")
	}

	nbPublicInputs := vk.NbPublicWitness()
	fmt.Println("nbPublicInputs:", nbPublicInputs)

	// convert public inputs
	nbInputs := len(inputBytes) / fr.Bytes
	if nbInputs != nbPublicInputs {
		panic("nbInputs != nbPublicInputs")
	}

	//FIXME change 1 to nbPublicInputs
	var input [1]*big.Int
	for i := 0; i < nbInputs; i++ {
		var e fr.Element
		e.SetBytes(inputBytes[fr.Bytes*i : fr.Bytes*(i+1)])
		input[i] = new(big.Int)
		e.BigInt(input[i])
	}

	// solidity contract inputs
	var eth_proof [8]*big.Int

	// proof.Ar, proof.Bs, proof.Krs
	for i := 0; i < 8; i++ {
		eth_proof[i] = new(big.Int).SetBytes(proofBytes[fpSize*i : fpSize*(i+1)])
	}

	fmt.Println("Public Inputs:", input)
	fmt.Println("ProofEth:", eth_proof)
}

func main() {
	// compiles our circuit into a R1CS
	var circuit CubicCircuit
	ccs, err := frontend.Compile(ecc.BN254.ScalarField(), r1cs.NewBuilder, &circuit)
	if err != nil {
		panic(err)
	}
	// groth16 zkSNARK: Setup
	pk, vk, err := groth16.Setup(ccs)
	if err != nil {
		panic(err)
	}

	// Write solidity smart contract into a file
	f, err := os.Create("./contract.sol")
	if err != nil {
		panic(err)
	}

	vk.ExportSolidity(f)

	// witness definition
	assignment := CubicCircuit{X: 3, Y: 35}
	witness, _ := frontend.NewWitness(&assignment, ecc.BN254.ScalarField())
	publicWitness, _ := witness.Public()

	// groth16: Prove & Verify
	proof, _ := groth16.Prove(ccs, pk, witness)
	groth16.Verify(proof, vk, publicWitness)

	printEthProofs(vk, proof, publicWitness)

}
